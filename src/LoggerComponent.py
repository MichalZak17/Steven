"""

This module defines functions and classes which implement a flexible event logging system for
applications and libraries. The module provides a lot of functionality and flexibility. If you are
unfamiliar with logging, the best way to get to grips with it is to see the tutorials.

The basic classes defined by the module, together with their functions, are listed below:

• Loggers expose the interface that application code directly uses.
• Handlers send the log records (created by loggers) to the appropriate destination.
• Filters provide a finer-grained facility for determining which log records to output.
• Formatters specify the layout of log records in the final output.

"""

import os
import time
import datetime

class LoggerClass:
    def __make_log(self, lvl = "warning", err = "0x0", arg = "None", date = True):
        """
        Returns a text message that is written to the event log as log.

        Args:
            lvl (str, optional): [description]. Defaults to "warning".
            err (str, optional): [description]. Defaults to "0x0".
            arg (str, optional): [description]. Defaults to "None".
            date (bool, optional): [description]. Defaults to True.

        Returns:
            str: Returns a text message that is written to the event log as log.
        """
        part_one    = f"{str(lvl).upper()}; "
        part_two    = f"{str(datetime.datetime.now())}; "
        part_three  = f"{str(err)}; "
        part_four   = f"{str(arg)}; "

        if date:
            part_one += part_two

        part_one += part_three
        part_one += part_four

        return f"{part_one}\n"

    def __init__(self):

        self.__directory = {
            "data": "data"
        }
        self.__file = {
            "logs": "data/logs.log"
        }

        self.__TRIES            =       5
        self.__LOWEST_CODE      =       -1
        self.__HIGHEST_CODE     =       24

        # Extensive priority codes
        self.LOG_EMERGENCY      =       0   # System is unusable.
        self.LOG_ALERT          =       1   # Action must be taken immediately.
        self.LOG_CRITICAL       =       2   # Critical conditions.
        self.LOG_ERROR          =       3   # Error conditions.
        self.LOG_WARNING        =       4   # Warning conditions.
        self.LOG_NOTICE         =       5   # Normal but significant condition.
        self.LOG_INFO           =       6   # Informational.
        self.LOG_DEBUG          =       7   # Debug-level messages.

        # Extensive facility codes
        self.LOG_KERNEL         =       0   # Kernel messages.
        self.LOG_USER           =       1   # Random user-level messages.
        self.LOG_MAIL           =       2   # Mail system.
        self.LOG_DAEMON         =       3   # System daemons.
        self.LOG_AUTH           =       4   # Security/authorization messages.
        self.LOG_SYSLOG         =       5   # Messages generated by syslog.
        self.LOG_LPR            =       6   # Line printer subsystem.
        self.LOG_NEWS           =       7   # Network news subsystem.
        self.LOG_UUCP           =       8   # UUCP subsystem.
        self.LOG_CRON           =       9   # Clock daemon.
        self.LOG_AUTHPRIV       =       10  # Security/authorization messages.
        self.LOG_FTP            =       11  # FTP daemon.
        self.LOG_NTP            =       12  # NTP subsystem.
        self.LOG_SECURITY       =       13  # Log audit.
        self.LOG_CONSOLE        =       14  # Log alert.
        self.LOG_SOLCRON        =       15  # Scheduling daemon (Solaris).

        # Other codes through 15 reserved for system use.
        self.LOG_LOCAL0         =       16  # Reserved for local use
        self.LOG_LOCAL1         =       17  # Reserved for local use
        self.LOG_LOCAL2         =       18  # Reserved for local use
        self.LOG_LOCAL3         =       19  # Reserved for local use
        self.LOG_LOCAL4         =       20  # Reserved for local use
        self.LOG_LOCAL5         =       21  # Reserved for local use
        self.LOG_LOCAL6         =       22  # Reserved for local use
        self.LOG_LOCAL7         =       23  # Reserved for local use

        self.__priority_names = {
            "alert":        self.LOG_ALERT,
            "crit":         self.LOG_CRITICAL,
            "critical":     self.LOG_CRITICAL,
            "debug":        self.LOG_DEBUG,
            "emerg":        self.LOG_EMERGENCY,
            "emergency":    self.LOG_EMERGENCY,
            "err":          self.LOG_ERROR,
            "error":        self.LOG_ERROR,
            "info":         self.LOG_INFO,
            "notice":       self.LOG_NOTICE,
            "panic":        self.LOG_EMERGENCY,
            "warn":         self.LOG_WARNING,
            "warning":      self.LOG_WARNING,
        }

        self.__facility_names = {
            "auth":         self.LOG_AUTH,
            "authpriv":     self.LOG_AUTHPRIV,
            "console":      self.LOG_CONSOLE,
            "cron":         self.LOG_CRON,
            "daemon":       self.LOG_DAEMON,
            "ftp":          self.LOG_FTP,
            "kern":         self.LOG_KERNEL,
            "lpr":          self.LOG_LPR,
            "mail":         self.LOG_MAIL,
            "news":         self.LOG_NEWS,
            "ntp":          self.LOG_NTP,
            "security":     self.LOG_SECURITY,
            "solaris-cron": self.LOG_SOLCRON,
            "syslog":       self.LOG_SYSLOG,
            "user":         self.LOG_USER,
            "uucp":         self.LOG_UUCP,
            "local0":       self.LOG_LOCAL0,
            "local1":       self.LOG_LOCAL1,
            "local2":       self.LOG_LOCAL2,
            "local3":       self.LOG_LOCAL3,
            "local4":       self.LOG_LOCAL4,
            "local5":       self.LOG_LOCAL5,
            "local6":       self.LOG_LOCAL6,
            "local7":       self.LOG_LOCAL7,
        }

        # --------------------------------------------------------------------

        self.__file             = ""
        self.__mode             = ""
        self.__level            = 0
        self.__date             = True
        self.__encode           = False
        self.__custom_extension = False

        # --------------------------------------------------------------------

    def config(self, file = "logs.log", mode = "a", level = "info", date = True,
               encode = False, custom_extension = False):
        """
        Early logger configuration to define basic elements

        Args:
            file (str, optional): Defines the event log file. Defaults to "logs.log".
            mode (str, optional): Defines the file type of opening and writing to the file. Defaults to "a".
            level (str, optional): Defines the log logging type. Defaults to "info".
            date (bool, optional): Defines whether the date should be included in the logs. Defaults to True.
            encode (bool, optional): Defines whether the arguments are to be encoded. Defaults to False.
            custom_extension (bool, optional): Defines whether the user may use an extension other than .log. Defaults to False.

        Raises:
            TypeError: Incorrect type for custom_extension parameter.
            OSError: File cannot be created.
            OSError: File cannot be created.
            OSError: File cannot be created.
            OSError: File cannot be created.
            ValueError: Unknown priority code.
            ValueError: Unknown priority code.
            ValueError: Unknown priority code.
            ValueError: Unknown priority code.
            ValueError: Incorrect opening type.
        """

        if isinstance(custom_extension, bool):
            self.__custom_extension = custom_extension

        else:
            raise TypeError("Incorrect type for custom_extension parameter.")

        # -------------------------------------------------------------------------------------------------------------

        if not self.__custom_extension:
            try:
                file = file.replace(str(file.split(".")[-1]), "log")
            except:
                pass

            if not str(file.split(".")[-1]) == "log":
                file += ".log"

        # -------------------------------------------------------------------------------------------------------------

        if not os.path.exists("{}/{}".format(str(self.__directory["data"]), str(file))):
            if os.path.exists(str(self.__directory["data"])):
                for i in range(self.__TRIES):
                    try:
                        self.__log = open(
                            f"{str(self.__directory['data'])}/{str(file)}", "w")
                    except:
                        pass
                    else:
                        self.__file = "{}/{}".format(
                            str(self.__directory["data"]), str(file))
                        self.__log.close()
                        break

                else:
                    raise OSError(
                        "The '{}/{}' file cannot be created.".format(str(self.__directory["data"]), str(file)))

            else:
                raise OSError("The '{}' directory has been deleted.".format(
                    str(self.__directory["data"])))

        else:
            if os.path.exists(str(self.__directory["data"])):
                for i in range(self.__TRIES):
                    try:
                        self.__log = open(
                            f"{str(self.__directory['data'])}/{str(file)}", "r")
                    except:
                        pass
                    else:
                        self.__file = "{}/{}".format(
                            str(self.__directory["data"]), str(file))
                        self.__log.close()
                        break

                else:
                    raise OSError(
                        "The '{}/{}' file cannot be created.".format(str(self.__directory["data"]), str(file)))

            else:
                raise OSError("The '{}' directory has been deleted.".format(
                    str(self.__directory["data"])))

        # -------------------------------------------------------------------------------------------------------------

        if isinstance(level, int):
            if level > self.__LOWEST_CODE and level < self.__HIGHEST_CODE:
                self.__level = level
            else:
                raise ValueError("Unknown priority code.")

        elif isinstance(level, str):
            try:
                self.__level = self.__priority_names[level.lower()]
            except:
                raise ValueError("Unknown priority code.")
        else:
            raise ValueError("Unknown priority code.")

        # -------------------------------------------------------------------------------------------------------------

        opening_modes_temp = ["w", "wb", "a"]

        if isinstance(mode, str):
            if not mode in opening_modes_temp:
                raise ValueError("Incorrect opening type.")
            else:
                self.__mode = mode

        else:
            raise ValueError("File mode must be str.")

        del opening_modes_temp

        self.__date = date
        self.__encode = encode

        # -------------------------------------------------------------------------------------------------------------

    def __encoder(self, arg):
        """
        Encodes the user-supplied argument into bytes.

        Args:
            arg ([type]): [description]

        Returns:
            bytes: Returns an argument converted to bytes ready for an event log entry
        """

        if self.__encode: return arg.encode()
        else: return arg

    def emergency(self, error = "0x0", args = "None"):
        """

        Enters logs to the event log file.

        Args:
            error (str, optional): Holds an error code. Defaults to "0x0".
            args (str, optional): Keeps any additional information. Defaults to "None".

        """

        with open(self.__file, self.__mode) as f:
            f.write(self.__make_log(lvl = "EMERGENCY", date = self.__date,
                    err = error, arg = self.__encoder(args)))

    def alert(self, error="0x0", args="None"):
        """

        Enters logs to the event log file.

        Args:
            error (str, optional): Holds an error code. Defaults to "0x0".
            args (str, optional): Keeps any additional information. Defaults to "None".

        """

        with open(self.__file, self.__mode) as f:
            f.write(self.__make_log(lvl = "ALERT", date = self.__date,
                    err = error, arg = self.__encoder(args)))

    def critical(self, error="0x0", args="None"):
        """

        Enters logs to the event log file.

        Args:
            error (str, optional): Holds an error code. Defaults to "0x0".
            args (str, optional): Keeps any additional information. Defaults to "None".

        """

        with open(self.__file, self.__mode) as f:
            f.write(self.__make_log(lvl = "CRITICAL", date = self.__date,
                    err = error, arg = self.__encoder(args)))

    def error(self, error = "0x0", args = "None"):
        """

        Enters logs to the event log file.

        Args:
            error (str, optional): Holds an error code. Defaults to "0x0".
            args (str, optional): Keeps any additional information. Defaults to "None".

        """

        with open(self.__file, self.__mode) as f:
            f.write(self.__make_log(lvl = "ERROR", date = self.__date,
                    err = error, arg = self.__encoder(args)))

    def warning(self, error = "0x0", args = "None"):
        """

        Enters logs to the event log file.

        Args:
            error (str, optional): Holds an error code. Defaults to "0x0".
            args (str, optional): Keeps any additional information. Defaults to "None".

        """

        with open(self.__file, self.__mode) as f:
            f.write(self.__make_log(lvl = "WARNING", date = self.__date,
                    err = error, arg = self.__encoder(args)))

    def notice(self, error = "0x0", args = "None"):
        """

        Enters logs to the event log file.

        Args:
            error (str, optional): Holds an error code. Defaults to "0x0".
            args (str, optional): Keeps any additional information. Defaults to "None".

        """

        with open(self.__file, self.__mode) as f:
            f.write(self.__make_log(lvl = "NOTICE", date = self.__date,
                    err = error, arg = self.__encoder(args)))

    def info(self, error = "0x0", args = "None"):
        """

        Enters logs to the event log file.

        Args:
            error (str, optional): Holds an error code. Defaults to "0x0".
            args (str, optional): Keeps any additional information. Defaults to "None".

        """

        with open(self.__file, self.__mode) as f:
            f.write(self.__make_log(lvl = "INFO", date = self.__date,
                    err = error, arg = self.__encoder(args)))

    def debug(self, error = "0x0", args = "None"):
        """

        Enters logs to the event log file.

        Args:
            error (str, optional): Holds an error code. Defaults to "0x0".
            args (str, optional): Keeps any additional information. Defaults to "None".

        """
        
        with open(self.__file, self.__mode) as f:
            f.write(self.__make_log(lvl = "DEBUG", date = self.__date,
                    err = error, arg = self.__encoder(args)))
